#include <stdio.h>
#include <stdlib.h>

#define N 3  // Количество узлов (x = 0.7, 0.8, 0.9, 1.0)
#define h 0.1

void thomas_algorithm(double a[N], double b[N], double c[N], double d[N], double y[N]) {
    // Прямой ход
    for (int i = 1; i < N; i++) {
        double m = a[i] / b[i-1];
        b[i] -= m * c[i-1];
        d[i] -= m * d[i-1];
    }

    // Обратный ход
    y[N-1] = d[N-1] / b[N-1];
    for (int i = N-2; i >= 0; i--) {
        y[i] = (d[i] - c[i] * y[i+1]) / b[i];
    }
}

int main() {
    double a[N], b[N], c[N], d[N], y[N+1];

    // Заполнение коэффициентов для внутренних узлов
    for (int i = 1; i < N-1; i++) {
        double xi = 0.7 + i * h;
        a[i] = 1;  // Коэффициент для y_{i-1}
        b[i] = -2 - 2 * h * h + 3 * xi * h;  // Коэффициент для y_i
        c[i] = 1 - 3 * xi * h;  // Коэффициент для y_{i+1}
        d[i] = 1.5 * h * h;  // Правая часть
    }

    // Краевое условие y'(0.7) = 1.3
    b[0] = -1;  // Коэффициент для y_0
    c[0] = 1;   // Коэффициент для y_1
    d[0] = 1.3 * h;  // Правая часть

    // Краевое условие 0.5y(1) + y'(1) = 1.2
    a[N-1] = -1;  // Коэффициент для y_{N-2}
    b[N-1] = 0.5 + 1 / h;  // Коэффициент для y_{N-1}
    d[N-1] = 1.2;  // Правая часть

    // Решение системы методом прогонки
    thomas_algorithm(a, b, c, d, y);

    // Заполнение массива y (включая граничные точки)
    y[0] = y[0];  // y(0.7)
    y[1] = y[1];  // y(0.8)
    y[2] = y[2];  // y(0.9)
    y[3] = y[2];  // y(1.0) - используется значение из предыдущего узла

    // Вывод результатов в виде таблицы
    printf("x\t\ty\n");
    for (int i = 0; i <= N; i++) {
        double xi = 0.7 + i * h;
        printf("%.2f\t%.6f\n", xi, y[i]);
    }

    return 0;
}